"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEngineImports = exports.EngineDelegate = exports.EngineDelegateEventType = exports.EngineMode = exports.isErrorResult = void 0;
// ðŸ™ˆ
var paperclip_utils_1 = require("paperclip-utils");
var utils_1 = require("./utils");
var isErrorResult = function (data) {
    return data.error != null;
};
exports.isErrorResult = isErrorResult;
var EngineMode;
(function (EngineMode) {
    EngineMode[EngineMode["SingleFrame"] = 0] = "SingleFrame";
    EngineMode[EngineMode["MultiFrame"] = 1] = "MultiFrame";
})(EngineMode = exports.EngineMode || (exports.EngineMode = {}));
var mapResult = function (result) {
    if (!result) {
        return result;
    }
    if (result.Ok) {
        return result.Ok;
    }
    else {
        return { error: result.Err };
    }
};
var EngineDelegateEventType;
(function (EngineDelegateEventType) {
    EngineDelegateEventType["Loaded"] = "Loaded";
    EngineDelegateEventType["ChangedSheets"] = "ChangedSheets";
})(EngineDelegateEventType = exports.EngineDelegateEventType || (exports.EngineDelegateEventType = {}));
/*
Engine delegate is the bridge between JS and the rust engine. Primary reason
for this class instead of shoving functionality into the engine itself is for performance &
reducing amount of data being passed between Rust <-> JS
*/
var EngineDelegate = /** @class */ (function () {
    function EngineDelegate(_native, _io, _onCrash) {
        var _this = this;
        if (_onCrash === void 0) { _onCrash = utils_1.noop; }
        this._native = _native;
        this._io = _io;
        this._onCrash = _onCrash;
        this._listeners = [];
        this._rendered = {};
        this._documents = {};
        this._graph = {};
        this._onEngineEvent = function (event) {
            if (!_this._documents[event.uri]) {
                _this._documents[event.uri] = _this._io.readFile(event.uri);
            }
            if (event.kind === paperclip_utils_1.EngineDelegateEventKind.Deleted) {
                delete _this._rendered[event.uri];
            }
            else if (event.kind === paperclip_utils_1.EngineDelegateEventKind.Evaluated) {
                _this._rendered = (0, paperclip_utils_1.updateAllLoadedData)(_this._rendered, event);
                _this._dispatch({
                    kind: paperclip_utils_1.EngineDelegateEventKind.Loaded,
                    uri: event.uri,
                    data: _this._rendered[event.uri]
                });
            }
            else if (event.kind === paperclip_utils_1.EngineDelegateEventKind.Diffed) {
                var existingData = _this._rendered[event.uri];
                _this._rendered = (0, paperclip_utils_1.updateAllLoadedData)(_this._rendered, event);
                var newData = _this._rendered[event.uri];
                if (existingData.kind === paperclip_utils_1.EvaluatedDataKind.PC &&
                    newData.kind === paperclip_utils_1.EvaluatedDataKind.PC) {
                    _this._handlePCDiff(event, existingData, newData);
                }
            }
        };
        this._handlePCDiff = function (event, existingData, newData) {
            var removedSheetUris = [];
            var diffData = event.data;
            for (var _i = 0, _a = existingData.importedSheets; _i < _a.length; _i++) {
                var uri = _a[_i].uri;
                if (!newData.allImportedSheetUris.includes(uri)) {
                    removedSheetUris.push(uri);
                }
            }
            var addedSheets = [];
            for (var i = 0, length_1 = diffData.allImportedSheetUris.length; i < length_1; i++) {
                var depUri = diffData.allImportedSheetUris[i];
                // Note that we only do this if the sheet is already rendered -- engine
                // doesn't fire an event in that scenario. So we need to notify any listener that a sheet
                // has been added, including the actual sheet object.
                if (!existingData.allImportedSheetUris.includes(depUri) &&
                    _this._rendered[depUri]) {
                    addedSheets.push({
                        uri: depUri,
                        index: i,
                        sheet: _this._rendered[depUri].sheet
                    });
                }
            }
            if (addedSheets.length || removedSheetUris.length) {
                _this._dispatch({
                    uri: event.uri,
                    kind: paperclip_utils_1.EngineDelegateEventKind.ChangedSheets,
                    data: {
                        // TODO - don't do this - instead include newSheetUris and
                        // allow renderer to fetch these sheets
                        newSheets: addedSheets,
                        removedSheetUris: removedSheetUris,
                        allImportedSheetUris: diffData.allImportedSheetUris
                    }
                });
            }
        };
        this._tryCatch = function (fn) {
            try {
                return fn();
            }
            catch (e) {
                _this._onCrash(e);
                return null;
            }
        };
        this._dispatch = function (event) {
            // try-catch since engine will throw opaque error.
            for (var _i = 0, _a = _this._listeners; _i < _a.length; _i++) {
                var listener = _a[_i];
                listener(event);
            }
        };
        // only one native listener to for buffer performance
        this._native.add_listener(this._dispatch);
        this.onEvent(this._onEngineEvent);
        return this;
    }
    EngineDelegate.prototype.resolveFile = function (fromPath, toPath) {
        return this._io.resolveFile(fromPath, toPath);
    };
    EngineDelegate.prototype.onEvent = function (listener) {
        var _this = this;
        if (listener == null) {
            throw new Error("listener cannot be undefined");
        }
        this._listeners.push(listener);
        return function () {
            var i = _this._listeners.indexOf(listener);
            if (i !== -1) {
                _this._listeners.splice(i, 1);
            }
        };
    };
    EngineDelegate.prototype.parseFile = function (uri) {
        return mapResult(this._native.parse_file(uri));
    };
    EngineDelegate.prototype.lint = function (uri) {
        return this._native.lint_file(uri);
    };
    EngineDelegate.prototype.getVirtualNodeSourceInfo = function (nodePath, uri) {
        return this._native.get_virtual_node_source_info(nodePath, uri);
    };
    EngineDelegate.prototype.generateCoverageReport = function () {
        var _this = this;
        return this._tryCatch(function () {
            return mapResult(_this._native.generate_coverage_report());
        });
    };
    EngineDelegate.prototype.getLoadedAst = function (uri) {
        var _this = this;
        return this._tryCatch(function () { return _this._native.get_loaded_ast(uri); });
    };
    EngineDelegate.prototype.getLoadedDependency = function (uri) {
        var _this = this;
        return (this._graph[uri] ||
            (this._graph[uri] = this._tryCatch(function () {
                return _this._native.get_dependency(uri);
            })));
    };
    EngineDelegate.prototype.parseContent = function (content, uri) {
        var _this = this;
        return this._tryCatch(function () {
            return mapResult(_this._native.parse_content(content, uri));
        });
    };
    EngineDelegate.prototype.purgeUnlinkedFiles = function () {
        var _this = this;
        return this._tryCatch(function () {
            var ret = mapResult(_this._native.purge_unlinked_files());
            return ret;
        });
    };
    EngineDelegate.prototype.getVirtualContent = function (uri) {
        return this._documents[uri];
    };
    EngineDelegate.prototype.updateVirtualFileContent = function (uri, content) {
        var _this = this;
        if (this._documents[uri] === content) {
            return;
        }
        this._graph[uri] = undefined;
        // only define if successfuly loaded
        this._documents[uri] = content;
        return this._tryCatch(function () {
            var ret = mapResult(_this._native.update_virtual_file_content(uri, content));
            return ret;
        });
    };
    EngineDelegate.prototype.inspectNodeStyles = function (source, screenWidth) {
        return this._native.inspect_node_styles(source.path, source.uri, screenWidth);
    };
    EngineDelegate.prototype.getLoadedData = function (uri) {
        return this._rendered[uri];
    };
    EngineDelegate.prototype.getExpressionById = function (id) {
        return this._native.get_expression_by_id(id);
    };
    EngineDelegate.prototype.getAllLoadedData = function () {
        return this._rendered;
    };
    EngineDelegate.prototype.getLoadedGraph = function () {
        var map = {};
        for (var uri in this._rendered) {
            map[uri] = this.getLoadedDependency(uri);
        }
        return map;
    };
    EngineDelegate.prototype.reset = function () {
        this._rendered = {};
        this._documents = {};
        this._native.reset();
    };
    EngineDelegate.prototype.open = function (uri) {
        var _this = this;
        this._graph[uri] = undefined;
        // need to load document so that it's accessible via source writer
        if (!this._documents[uri]) {
            this._documents[uri] = this._io.readFile(uri);
        }
        var result = this._tryCatch(function () { return mapResult(_this._native.run(uri)); });
        if (result && result.error) {
            throw result.error;
        }
        return this._rendered[uri];
    };
    return EngineDelegate;
}());
exports.EngineDelegate = EngineDelegate;
/**
 * Kept separate from the engine since this is more of a util function for ID inspection
 */
var getEngineImports = function (uri, delegate) {
    var data = delegate.getLoadedData(uri);
    if ((data === null || data === void 0 ? void 0 : data.kind) === paperclip_utils_1.EvaluatedDataKind.PC) {
        var ast_1 = delegate.getLoadedAst(uri);
        return Object.keys(data.dependencies).reduce(function (record, id) {
            var depUri = data.dependencies[id];
            var imp = ast_1 && ((0, paperclip_utils_1.getImportById)(id, ast_1) || (0, paperclip_utils_1.getImportBySrc)(id, ast_1));
            record[id] = __assign({ uri: imp && (0, paperclip_utils_1.getAttributeStringValue)("src", imp), injectStyles: imp && (0, paperclip_utils_1.hasAttribute)(paperclip_utils_1.INJECT_STYLES_TAG_NAME, imp) }, delegate.getLoadedData(depUri));
            return record;
        }, {});
    }
    else {
        return {};
    }
};
exports.getEngineImports = getEngineImports;
