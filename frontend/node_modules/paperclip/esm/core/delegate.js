// ðŸ™ˆ
import { updateAllLoadedData, EngineDelegateEventKind, EvaluatedDataKind, getImportById, getImportBySrc, getAttributeStringValue, hasAttribute, INJECT_STYLES_TAG_NAME } from "paperclip-utils";
import { noop } from "./utils";
export const isErrorResult = (data) => {
    return data.error != null;
};
export var EngineMode;
(function (EngineMode) {
    EngineMode[EngineMode["SingleFrame"] = 0] = "SingleFrame";
    EngineMode[EngineMode["MultiFrame"] = 1] = "MultiFrame";
})(EngineMode || (EngineMode = {}));
const mapResult = (result) => {
    if (!result) {
        return result;
    }
    if (result.Ok) {
        return result.Ok;
    }
    else {
        return { error: result.Err };
    }
};
export var EngineDelegateEventType;
(function (EngineDelegateEventType) {
    EngineDelegateEventType["Loaded"] = "Loaded";
    EngineDelegateEventType["ChangedSheets"] = "ChangedSheets";
})(EngineDelegateEventType || (EngineDelegateEventType = {}));
/*
Engine delegate is the bridge between JS and the rust engine. Primary reason
for this class instead of shoving functionality into the engine itself is for performance &
reducing amount of data being passed between Rust <-> JS
*/
export class EngineDelegate {
    constructor(_native, _io, _onCrash = noop) {
        this._native = _native;
        this._io = _io;
        this._onCrash = _onCrash;
        this._listeners = [];
        this._rendered = {};
        this._documents = {};
        this._graph = {};
        this._onEngineEvent = (event) => {
            if (!this._documents[event.uri]) {
                this._documents[event.uri] = this._io.readFile(event.uri);
            }
            if (event.kind === EngineDelegateEventKind.Deleted) {
                delete this._rendered[event.uri];
            }
            else if (event.kind === EngineDelegateEventKind.Evaluated) {
                this._rendered = updateAllLoadedData(this._rendered, event);
                this._dispatch({
                    kind: EngineDelegateEventKind.Loaded,
                    uri: event.uri,
                    data: this._rendered[event.uri]
                });
            }
            else if (event.kind === EngineDelegateEventKind.Diffed) {
                const existingData = this._rendered[event.uri];
                this._rendered = updateAllLoadedData(this._rendered, event);
                const newData = this._rendered[event.uri];
                if (existingData.kind === EvaluatedDataKind.PC &&
                    newData.kind === EvaluatedDataKind.PC) {
                    this._handlePCDiff(event, existingData, newData);
                }
            }
        };
        this._handlePCDiff = (event, existingData, newData) => {
            const removedSheetUris = [];
            const diffData = event.data;
            for (const { uri } of existingData.importedSheets) {
                if (!newData.allImportedSheetUris.includes(uri)) {
                    removedSheetUris.push(uri);
                }
            }
            const addedSheets = [];
            for (let i = 0, { length } = diffData.allImportedSheetUris; i < length; i++) {
                const depUri = diffData.allImportedSheetUris[i];
                // Note that we only do this if the sheet is already rendered -- engine
                // doesn't fire an event in that scenario. So we need to notify any listener that a sheet
                // has been added, including the actual sheet object.
                if (!existingData.allImportedSheetUris.includes(depUri) &&
                    this._rendered[depUri]) {
                    addedSheets.push({
                        uri: depUri,
                        index: i,
                        sheet: this._rendered[depUri].sheet
                    });
                }
            }
            if (addedSheets.length || removedSheetUris.length) {
                this._dispatch({
                    uri: event.uri,
                    kind: EngineDelegateEventKind.ChangedSheets,
                    data: {
                        // TODO - don't do this - instead include newSheetUris and
                        // allow renderer to fetch these sheets
                        newSheets: addedSheets,
                        removedSheetUris: removedSheetUris,
                        allImportedSheetUris: diffData.allImportedSheetUris
                    }
                });
            }
        };
        this._tryCatch = (fn) => {
            try {
                return fn();
            }
            catch (e) {
                this._onCrash(e);
                return null;
            }
        };
        this._dispatch = (event) => {
            // try-catch since engine will throw opaque error.
            for (const listener of this._listeners) {
                listener(event);
            }
        };
        // only one native listener to for buffer performance
        this._native.add_listener(this._dispatch);
        this.onEvent(this._onEngineEvent);
        return this;
    }
    resolveFile(fromPath, toPath) {
        return this._io.resolveFile(fromPath, toPath);
    }
    onEvent(listener) {
        if (listener == null) {
            throw new Error(`listener cannot be undefined`);
        }
        this._listeners.push(listener);
        return () => {
            const i = this._listeners.indexOf(listener);
            if (i !== -1) {
                this._listeners.splice(i, 1);
            }
        };
    }
    parseFile(uri) {
        return mapResult(this._native.parse_file(uri));
    }
    lint(uri) {
        return this._native.lint_file(uri);
    }
    getVirtualNodeSourceInfo(nodePath, uri) {
        return this._native.get_virtual_node_source_info(nodePath, uri);
    }
    generateCoverageReport() {
        return this._tryCatch(() => {
            return mapResult(this._native.generate_coverage_report());
        });
    }
    getLoadedAst(uri) {
        return this._tryCatch(() => this._native.get_loaded_ast(uri));
    }
    getLoadedDependency(uri) {
        return (this._graph[uri] ||
            (this._graph[uri] = this._tryCatch(() => this._native.get_dependency(uri))));
    }
    parseContent(content, uri) {
        return this._tryCatch(() => mapResult(this._native.parse_content(content, uri)));
    }
    purgeUnlinkedFiles() {
        return this._tryCatch(() => {
            const ret = mapResult(this._native.purge_unlinked_files());
            return ret;
        });
    }
    getVirtualContent(uri) {
        return this._documents[uri];
    }
    updateVirtualFileContent(uri, content) {
        if (this._documents[uri] === content) {
            return;
        }
        this._graph[uri] = undefined;
        // only define if successfuly loaded
        this._documents[uri] = content;
        return this._tryCatch(() => {
            const ret = mapResult(this._native.update_virtual_file_content(uri, content));
            return ret;
        });
    }
    inspectNodeStyles(source, screenWidth) {
        return this._native.inspect_node_styles(source.path, source.uri, screenWidth);
    }
    getLoadedData(uri) {
        return this._rendered[uri];
    }
    getExpressionById(id) {
        return this._native.get_expression_by_id(id);
    }
    getAllLoadedData() {
        return this._rendered;
    }
    getLoadedGraph() {
        const map = {};
        for (const uri in this._rendered) {
            map[uri] = this.getLoadedDependency(uri);
        }
        return map;
    }
    reset() {
        this._rendered = {};
        this._documents = {};
        this._native.reset();
    }
    open(uri) {
        this._graph[uri] = undefined;
        // need to load document so that it's accessible via source writer
        if (!this._documents[uri]) {
            this._documents[uri] = this._io.readFile(uri);
        }
        const result = this._tryCatch(() => mapResult(this._native.run(uri)));
        if (result && result.error) {
            throw result.error;
        }
        return this._rendered[uri];
    }
}
/**
 * Kept separate from the engine since this is more of a util function for ID inspection
 */
export const getEngineImports = (uri, delegate) => {
    const data = delegate.getLoadedData(uri);
    if ((data === null || data === void 0 ? void 0 : data.kind) === EvaluatedDataKind.PC) {
        const ast = delegate.getLoadedAst(uri);
        return Object.keys(data.dependencies).reduce((record, id) => {
            const depUri = data.dependencies[id];
            const imp = ast && (getImportById(id, ast) || getImportBySrc(id, ast));
            record[id] = Object.assign({ uri: imp && getAttributeStringValue("src", imp), injectStyles: imp && hasAttribute(INJECT_STYLES_TAG_NAME, imp) }, delegate.getLoadedData(depUri));
            return record;
        }, {});
    }
    else {
        return {};
    }
};
