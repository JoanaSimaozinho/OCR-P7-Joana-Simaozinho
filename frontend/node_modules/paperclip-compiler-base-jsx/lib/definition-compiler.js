"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.definitionCompiler = void 0;
var paperclip_1 = require("paperclip");
var utils_1 = require("./utils");
var definitionCompiler = function (_a) {
    var imports = _a.imports, elementType = _a.elementType;
    var translateRoot = function (context) {
        context = (0, utils_1.addBuffer)([
            "/* eslint-disable */\n",
            imports,
            translateDefaultProps,
            "type Factory<TProps> = (props: TProps & DefaultProps) => ".concat(elementType, ";\n\n"),
            translateClassNames,
            translateComponents
        ])(context);
        return context;
    };
    var translateDefaultProps = (0, utils_1.addBuffer)([
        "type DefaultProps = {\n",
        utils_1.startBlock,
        "ref?: any,\n",
        utils_1.endBlock,
        "};\n\n"
    ]);
    var translateClassNames = function (context) {
        context = (0, utils_1.addBuffer)([
            "export declare const classNames: {\n",
            utils_1.startBlock,
            function (context) {
                var classNames = context.module.css.exports.classNames;
                for (var exportName in classNames) {
                    context = (0, utils_1.addBuffer)(["".concat(JSON.stringify(exportName), ": string,\n")])(context);
                }
                return context;
            },
            utils_1.endBlock,
            "};\n\n"
        ])(context);
        return context;
    };
    var DEFAULT_PARAM_TYPE = "any";
    var translateInference = function (property, inference) {
        if (inference.kind === paperclip_1.InferenceKind.Any) {
            return (0, utils_1.addBuffer)([
                /^on\w+/.test(property) ? "Function" : DEFAULT_PARAM_TYPE
            ]);
        }
        if (inference.kind === paperclip_1.InferenceKind.Array) {
            return (0, utils_1.addBuffer)([
                "Array<",
                translateInference(property, inference.value),
                ">"
            ]);
        }
        if (inference.kind === paperclip_1.InferenceKind.Shape) {
            return (0, utils_1.addBuffer)([
                "{\n",
                utils_1.startBlock,
                function (context) {
                    for (var key in inference.properties) {
                        context = translateProp(key, inference.properties[key])(context);
                    }
                    return context;
                },
                utils_1.endBlock,
                "}"
            ]);
        }
        return context;
    };
    var translateComponents = function (context) {
        return (0, utils_1.writeJoin)(context.module.components, "\n\n", translateComponent)(context);
    };
    var translateComponent = function (component) {
        var name = component.as === "default" ? "$$Default" : component.as;
        return (0, utils_1.addBuffer)([
            "type ".concat(name, "Props = {\n"),
            utils_1.startBlock,
            translateComponentProps(component),
            utils_1.endBlock,
            "}\n\n",
            "declare const ".concat(name, ": Factory<").concat(name, "Props>;\n\n"),
            component.as === "default"
                ? "export default ".concat(name, ";")
                : "export { ".concat(name, " };\n\n")
        ]);
    };
    var translateComponentProps = function (component) { return function (context) {
        var props = {};
        for (var key in component.schema.properties) {
            context = translateProp(key, component.schema.properties[key])(context);
            props[key] = [null];
        }
        return context;
    }; };
    var translateProp = function (key, _a) {
        var value = _a.value, optional = _a.optional;
        return (0, utils_1.addBuffer)([
            "".concat(key).concat(optional ? "?" : "", ": "),
            translateInference(key, value),
            ",\n"
        ]);
    };
    return function (module, filePath, config, targetOptions) {
        var context = (0, utils_1.createTranslateContext)(module, filePath, config, targetOptions);
        return translateRoot(context).buffer.join("");
    };
};
exports.definitionCompiler = definitionCompiler;
