import { ScriptExpression, Reference } from "../script/ast";
import { Sheet, MixinRule, StyleExpression } from "../css/ast";
import { BasicRaws, StringRange } from "../base/ast";
export declare enum NodeKind {
    Fragment = "Fragment",
    Text = "Text",
    Annotation = "Annotation",
    Comment = "Comment",
    Element = "Element",
    StyleElement = "StyleElement",
    Slot = "Slot"
}
export declare type BaseNode<TKind extends NodeKind> = {
    id: string;
    nodeKind: TKind;
};
export declare type Text = {
    value: string;
    range: StringRange;
} & BaseNode<NodeKind.Text>;
export declare type Annotation = {
    properties: AnnotationProperty[];
    range: StringRange;
} & BaseNode<NodeKind.Annotation>;
export declare type Comment = {
    raws: BasicRaws;
    value: string;
    annotation: Annotation;
    range: StringRange;
} & BaseNode<NodeKind.Comment>;
export declare enum AnnotationPropertyKind {
    Text = "Text",
    Declaration = "Declaration"
}
declare type BaseAnnotationProperty<TKind extends AnnotationPropertyKind> = {
    kind: TKind;
};
export declare type TextAnnotation = {
    value: string;
    raws: BasicRaws;
} & BaseAnnotationProperty<AnnotationPropertyKind.Text>;
export declare type DeclarationAnnotation = {
    name: string;
    value: ScriptExpression;
    raws: BasicRaws;
} & BaseAnnotationProperty<AnnotationPropertyKind.Declaration>;
export declare type AnnotationProperty = TextAnnotation | DeclarationAnnotation;
export declare type ElementRaws = {
    before: string;
};
export declare type Element = {
    id: string;
    range: StringRange;
    raws: ElementRaws;
    openTagRange: StringRange;
    tagNameRange: StringRange;
    tagName: string;
    attributes: Attribute[];
    value: string;
    children: Node[];
} & BaseNode<NodeKind.Element>;
export declare type StyleElement = {
    sheet: Sheet;
    range: StringRange;
    raws: BasicRaws;
} & BaseNode<NodeKind.StyleElement>;
export declare enum AttributeKind {
    ShorthandAttribute = "ShorthandAttribute",
    KeyValueAttribute = "KeyValueAttribute",
    SpreadAttribute = "SpreadAttribute",
    PropertyBoundAttribute = "PropertyBoundAttribute"
}
declare type BaseAttribute<TKind extends AttributeKind> = {
    attrKind: TKind;
};
declare type ShorthandAttribute = {
    id: string;
    reference: ScriptExpression;
    range: StringRange;
} & BaseAttribute<AttributeKind.ShorthandAttribute>;
declare type SpreadAttribute = {
    id: string;
    script: ScriptExpression;
    range: StringRange;
} & BaseAttribute<AttributeKind.SpreadAttribute>;
declare type KeyValueAttribute = {
    id: string;
    name: string;
    value?: AttributeValue;
    range: StringRange;
} & BaseAttribute<AttributeKind.KeyValueAttribute>;
export declare type PropertyBoundAttribute = {
    id: string;
    name: string;
    bindingName: string;
    value: AttributeValue;
    range: StringRange;
} & BaseAttribute<AttributeKind.PropertyBoundAttribute>;
export declare type Attribute = ShorthandAttribute | SpreadAttribute | KeyValueAttribute | PropertyBoundAttribute;
export declare enum AttributeValueKind {
    DyanmicString = "DyanmicString",
    String = "String",
    Slot = "Slot"
}
export declare type BaseAttributeValue<TKind extends AttributeValueKind> = {
    attrValueKind: TKind;
};
export declare type StringAttributeValue = {
    value: string;
    range: StringRange;
} & BaseAttributeValue<AttributeValueKind.String>;
export declare enum DynamicStringAttributeValuePartKind {
    Literal = "Literal",
    ClassNamePierce = "ClassNamePierce",
    Slot = "Slot"
}
declare type BaseDynamicStringAttributeValuePart<TPartKind extends DynamicStringAttributeValuePartKind> = {
    partKind: TPartKind;
};
declare type DynamicStringLiteralPart = {
    range: StringRange;
    value: string;
} & BaseDynamicStringAttributeValuePart<DynamicStringAttributeValuePartKind.Literal>;
declare type DynamicStringClassNamePiercePart = {
    range: StringRange;
    className: string;
} & BaseDynamicStringAttributeValuePart<DynamicStringAttributeValuePartKind.ClassNamePierce>;
declare type DynamicStringSlotPart = ScriptExpression & BaseDynamicStringAttributeValuePart<DynamicStringAttributeValuePartKind.Slot>;
export declare type DynamicStringAttributeValuePart = DynamicStringLiteralPart | DynamicStringClassNamePiercePart | DynamicStringSlotPart;
export declare type DynamicStringAttributeValue = {
    values: DynamicStringAttributeValuePart[];
    range: StringRange;
} & BaseAttributeValue<AttributeValueKind.DyanmicString>;
export declare type SlotAttributeValue = {
    script: ScriptExpression;
    range: StringRange;
} & BaseAttributeValue<AttributeValueKind.Slot>;
export declare type AttributeValue = StringAttributeValue | SlotAttributeValue | DynamicStringAttributeValue;
export declare type Fragment = {
    value: string;
    children: Node[];
    range: StringRange;
} & BaseNode<NodeKind.Fragment>;
export declare type Slot = {
    script: ScriptExpression;
    range: StringRange;
    raws: BasicRaws;
} & BaseNode<NodeKind.Slot>;
export declare type Node = Text | Element | StyleElement | Fragment | Slot | Annotation | Comment;
export declare type Expression = Node | Attribute | AttributeValue | StyleExpression | ScriptExpression | DynamicStringAttributeValuePart;
export declare const getImports: (ast: Node) => Element[];
export declare const getRelativeFilePath: (fs: any) => (fromFilePath: string, importFilePath: string) => string;
export declare const getImportIds: (ast: Node) => string[];
export declare const getImportById: (id: string, ast: Node) => Element | null;
export declare const getImportBySrc: (src: string, ast: Node) => Element | null;
export declare const getChildren: (ast: Node) => Node[];
export declare const getStyleScopeId: (filePath: string) => any;
export declare const getChildrenByTagName: (tagName: string, parent: Node) => Element[];
export declare const findByNamespace: (namespace: string, current: Node | ScriptExpression, allChildrenByNamespace?: Element[]) => Element[];
export declare const getMetaValue: (name: string, root: Node) => string;
export declare const getAttribute: (name: string, element: Element) => KeyValueAttribute;
export declare const getAttributeValue: (name: string, element: Element) => AttributeValue;
export declare const getAttributeStringValue: (name: string, element: Element) => string;
export declare const getStyleElements: (ast: Node) => StyleElement[];
export declare const isVisibleElement: (ast: Element) => boolean;
export declare const isVisibleNode: (node: Node) => boolean;
export declare const getVisibleChildNodes: (ast: Node) => Node[];
export declare const isComponent: (node: Node) => node is Element;
export declare const isImport: (node: Node) => node is Element;
export declare const getParts: (ast: Node) => Element[];
export declare const getPartIds: (ast: Node) => string[];
export declare const getDefaultPart: (ast: Node) => Element;
export declare const getLogicElement: (ast: Node) => Element | null;
export declare const hasAttribute: (name: string, element: Element) => boolean;
export declare const getParentNode: (node: Node, root: Node) => Element | Fragment;
export declare const getPCNodeAnnotations: (node: Node, root: Node) => Comment;
export declare const getNodeById: (nodeId: string, root: Node) => Node;
export declare const isComponentInstance: (node: Node, importIds: string[]) => node is Element;
export declare const getMixins: (ast: Node) => Record<string, MixinRule>;
export declare const isNode: (ast: Expression) => ast is Node;
export declare const isAttribute: (ast: Expression) => ast is Attribute;
export declare const isAttributeValue: (ast: Expression) => ast is AttributeValue;
export declare const isScriptExpression: (ast: Expression) => ast is ScriptExpression;
export declare const isDynamicStringAttributeValuePart: (ast: Expression) => ast is DynamicStringAttributeValuePart;
export declare const traverseExpression: (ast: Expression, each: (node: Expression) => void | boolean) => any;
export declare const getNestedReferences: (node: Node, _statements?: [Reference, string][]) => [Reference, string][];
export {};
