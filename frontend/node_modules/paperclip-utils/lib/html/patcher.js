"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateAllLoadedData = exports.getVirtTarget = exports.patchVirtNode = void 0;
var virt_mtuation_1 = require("./virt-mtuation");
var virt_1 = require("./virt");
var events_1 = require("../core/events");
var patcher_1 = require("../css/patcher");
var patchVirtNode = function (root, mutations) {
    for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
        var mutation = mutations_1[_i];
        var target = (0, exports.getVirtTarget)(root, mutation.nodePath);
        var action = mutation.action;
        switch (action.kind) {
            case virt_mtuation_1.ActionKind.DeleteChild: {
                var element = target;
                var children = element.children.concat();
                children.splice(action.index, 1);
                target = __assign(__assign({}, target), { children: children });
                break;
            }
            case virt_mtuation_1.ActionKind.InsertChild: {
                var element = target;
                var children = element.children.concat();
                children.splice(action.index, 0, action.child);
                target = __assign(__assign({}, target), { children: children });
                break;
            }
            case virt_mtuation_1.ActionKind.ReplaceNode: {
                target = action.replacement;
                break;
            }
            case virt_mtuation_1.ActionKind.RemoveAttribute: {
                var element = target;
                var attributes = __assign({}, element.attributes);
                delete attributes[action.name];
                target = __assign(__assign({}, target), { attributes: attributes });
                break;
            }
            case virt_mtuation_1.ActionKind.SetAttribute: {
                var element = target;
                var attributes = __assign({}, element.attributes);
                if (!action.value) {
                    attributes[action.name] = action.value;
                }
                else {
                    attributes[action.name] = action.value;
                }
                target = __assign(__assign({}, target), { attributes: attributes });
                break;
            }
            case virt_mtuation_1.ActionKind.SetElementSourceInfo: {
                target = __assign(__assign({}, target), { sourceInfo: action.value });
                break;
            }
            case virt_mtuation_1.ActionKind.SetAnnotations: {
                target = __assign(__assign({}, target), { annotations: action.value });
                break;
            }
            case virt_mtuation_1.ActionKind.SetText: {
                target = __assign(__assign({}, target), { value: action.value });
                break;
            }
        }
        root = updateNode(root, mutation.nodePath, target);
    }
    return root;
};
exports.patchVirtNode = patchVirtNode;
var getVirtTarget = function (mount, nodePath) {
    return nodePath.reduce(function (current, i) {
        var c = current.children[i];
        return c;
    }, mount);
};
exports.getVirtTarget = getVirtTarget;
var updateNode = function (ancestor, nodePath, newNode, depth) {
    if (depth === void 0) { depth = 0; }
    if (depth === nodePath.length) {
        return newNode;
    }
    if (ancestor.kind === virt_1.VirtualNodeKind.Text ||
        ancestor.kind === virt_1.VirtualNodeKind.StyleElement) {
        return newNode;
    }
    return __assign(__assign({}, ancestor), { children: __spreadArray(__spreadArray(__spreadArray([], ancestor.children.slice(0, nodePath[depth]), true), [
            updateNode(ancestor.children[nodePath[depth]], nodePath, newNode, depth + 1)
        ], false), ancestor.children.slice(nodePath[depth] + 1), true) });
};
var updateAllLoadedData = function (allData, event) {
    var _a;
    allData = updatePrimary(allData, event);
    // update dependents
    for (var name_1 in allData) {
        var info = allData[name_1];
        if (info.kind === virt_1.EvaluatedDataKind.PC) {
            if (info.allImportedSheetUris.includes(event.uri)) {
                allData = __assign(__assign({}, allData), (_a = {}, _a[name_1] = __assign(__assign({}, allData[name_1]), { importedSheets: getImportedSheets(allData, info.allImportedSheetUris) }), _a));
            }
        }
    }
    return allData;
};
exports.updateAllLoadedData = updateAllLoadedData;
var updatePrimary = function (allData, event) {
    var _a, _b, _c, _d;
    if (event.kind === events_1.EngineDelegateEventKind.Evaluated) {
        if (event.data.kind === virt_1.EvaluatedDataKind.PC) {
            return __assign(__assign({}, allData), (_a = {}, _a[event.uri] = __assign(__assign({}, event.data), { importedSheets: getImportedSheets(allData, event.data.allImportedSheetUris) }), _a));
        }
        else {
            return __assign(__assign({}, allData), (_b = {}, _b[event.uri] = __assign({}, event.data), _b));
        }
    }
    else if (event.kind === events_1.EngineDelegateEventKind.Diffed) {
        var existingData = allData[event.uri];
        // this will happen if client renderer loads data, but imported
        // resource has changed
        if (!existingData) {
            return allData;
        }
        if (event.data.kind === virt_1.DiffedDataKind.PC) {
            var existingPCData = existingData;
            return __assign(__assign({}, allData), (_c = {}, _c[event.uri] = __assign(__assign({}, existingPCData), { exports: event.data.exports, importedSheets: getImportedSheets(allData, event.data.allImportedSheetUris), allImportedSheetUris: event.data.allImportedSheetUris, dependencies: event.data.dependencies, sheet: (0, patcher_1.patchCSSSheet)(existingPCData.sheet, event.data.sheetMutations), preview: (0, exports.patchVirtNode)(existingPCData.preview, event.data.mutations) }), _c));
        }
        else {
            var existingCSSData = existingData;
            return __assign(__assign({}, allData), (_d = {}, _d[event.uri] = __assign(__assign({}, existingCSSData), { exports: event.data.exports, sheet: (0, patcher_1.patchCSSSheet)(existingCSSData.sheet, event.data.mutations) }), _d));
        }
    }
    return allData;
};
var getImportedSheets = function (allData, allImportedSheetUris) {
    // ick, wworks for now.
    var deps = [];
    for (var i = 0, length_1 = allImportedSheetUris.length; i < length_1; i++) {
        var depUri = allImportedSheetUris[i];
        var data = allData[depUri];
        if (data) {
            deps.push({ uri: depUri, index: i, sheet: data.sheet });
            // scenario won't happen for renderer since renderers are only
            // concerned about the file that's currently opened -- ignore for now. Might
        }
        else {
            // console.error(`data not loaded, this shouldn't happen ðŸ˜¬.`);
        }
    }
    return deps;
};
