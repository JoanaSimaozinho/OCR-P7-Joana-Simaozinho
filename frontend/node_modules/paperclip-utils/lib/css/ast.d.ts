import { BasicRaws, StringRange } from "../base/ast";
import { Expression } from "../html/ast";
export declare type Sheet = {
    rules: Rule[];
    raws: BasicRaws;
    declarations: StyleDeclaration[];
};
export declare enum RuleKind {
    Style = "Style",
    Charset = "Charset",
    Namespace = "Namespace",
    Include = "Include",
    Comment = "Comment",
    FontFace = "FontFace",
    Media = "Media",
    Mixin = "Mixin",
    Export = "Export",
    Supports = "Supports",
    Page = "Page",
    Document = "Document",
    Keyframes = "Keyframes",
    Keyframe = "Keyframe"
}
declare type BaseRule<TKind extends RuleKind> = {
    id: string;
    ruleKind: TKind;
    range: StringRange;
};
export declare enum SelectorKind {
    Group = "Group",
    Combo = "Combo",
    Descendent = "Descendent",
    This = "This",
    Within = "Within",
    Global = "Global",
    Prefixed = "Prefixed",
    PseudoElement = "PseudoElement",
    PseudoParamElement = "PseudoParamElement",
    Not = "Not",
    Child = "Child",
    Adjacent = "Adjacent",
    Sibling = "Sibling",
    Id = "Id",
    Element = "Element",
    Attribute = "Attribute",
    Class = "Class",
    AllSelector = "AllSelector"
}
export declare type BaseSelector<TKind extends SelectorKind> = {
    id: string;
    selectorKind: TKind;
    range: StringRange;
};
declare type GroupSelector = {
    selectors: Selector[];
} & BaseSelector<SelectorKind.Group>;
declare type WithinSelector = {
    selector: Selector;
} & BaseSelector<SelectorKind.Within>;
declare type GlobalSelector = {
    selector: Selector;
} & BaseSelector<SelectorKind.Global>;
declare type SelfSelector = {
    selector: Selector;
} & BaseSelector<SelectorKind.This>;
declare type PrefixedSelector = {
    connector: string;
    postfixSelector?: Selector;
} & BaseSelector<SelectorKind.Prefixed>;
declare type ComboSelector = {
    selectors: Selector[];
} & BaseSelector<SelectorKind.Combo>;
declare type DescendentSelector = {
    ancestor: Selector;
    descendent: Selector;
} & BaseSelector<SelectorKind.Descendent>;
declare type PseudoElementSelector = {
    separator: string;
    target: Selector;
    name: string;
} & BaseSelector<SelectorKind.PseudoElement>;
declare type PseudoParamElementSelector = {
    target: Selector;
    name: string;
    param: string;
} & BaseSelector<SelectorKind.PseudoParamElement>;
declare type NotSelector = {
    selector: Selector;
} & BaseSelector<SelectorKind.Not>;
declare type ChildSelector = {
    parent: Selector;
    child: Selector;
} & BaseSelector<SelectorKind.Child>;
declare type AdjacentSelector = {
    selector: Selector;
    nextSiblingSelector: Selector;
} & BaseSelector<SelectorKind.Adjacent>;
declare type SiblingSelector = {
    selector: Selector;
    siblingSelector: Selector;
} & BaseSelector<SelectorKind.Sibling>;
declare type IdSelector = {
    id: string;
} & BaseSelector<SelectorKind.Id>;
declare type ElementSelector = {
    tagName: string;
} & BaseSelector<SelectorKind.Element>;
declare type AttributeSelector = {
    operator?: string;
    name: string;
    value?: string;
} & BaseSelector<SelectorKind.Attribute>;
declare type ClassSelector = {
    className: string;
} & BaseSelector<SelectorKind.Class>;
declare type AllSelector = BaseSelector<SelectorKind.AllSelector>;
export declare type Selector = GroupSelector | WithinSelector | GlobalSelector | PrefixedSelector | ComboSelector | DescendentSelector | SelfSelector | PseudoElementSelector | PseudoParamElementSelector | NotSelector | ChildSelector | AdjacentSelector | SiblingSelector | IdSelector | ElementSelector | AttributeSelector | ClassSelector | AllSelector;
export declare enum StyleDeclarationKind {
    KeyValue = "KeyValue",
    Include = "Include",
    Media = "Media",
    Content = "Content"
}
declare type BaseStyleDeclaration<TKind extends StyleDeclarationKind> = {
    id: string;
    declarationKind: TKind;
    range: StringRange;
};
export declare type KeyValueDeclaration = {
    name: string;
    value: string;
    range: StringRange;
    nameRange: StringRange;
    valueRange: StringRange;
    raws: BasicRaws;
} & BaseStyleDeclaration<StyleDeclarationKind.KeyValue>;
export declare type MediaDeclaration = ConditionShape & BaseStyleDeclaration<StyleDeclarationKind.Media>;
export declare type Include = BaseInclude & BaseStyleDeclaration<StyleDeclarationKind.Include>;
export declare type Content = {
    raws: BasicRaws;
} & BaseStyleDeclaration<StyleDeclarationKind.Content>;
export declare type IncludeReference = {
    id: string;
    parts: IncludePart[];
    range: StringRange;
};
export declare type IncludePart = {
    id: string;
    name: string;
    range: StringRange;
};
export declare type StyleDeclaration = KeyValueDeclaration | Include | MediaDeclaration | Content;
export declare type StyleRule = {
    range: StringRange;
    selector: Selector;
    declarations: StyleDeclaration[];
    children: StyleRule[];
    raws: BasicRaws;
} & BaseRule<RuleKind.Style>;
export declare type KeyframeRule = {
    key: string;
    raws: BasicRaws;
    declarations: StyleDeclaration[];
    range: StringRange;
} & BaseRule<RuleKind.Keyframe>;
export declare type KeyframesRule = {
    name: string;
    rules: KeyframeRule[];
    raws: BasicRaws;
    range: StringRange;
} & BaseRule<RuleKind.Keyframes>;
declare type ConditionShape = {
    name: string;
    conditionText: string;
    rules: ChildRule[];
    raws: BasicRaws;
    range: StringRange;
    declarations: StyleDeclaration[];
};
declare type BaseConditionRule<TRule extends RuleKind> = ConditionShape & BaseRule<TRule>;
declare type MediaRule = BaseConditionRule<RuleKind.Media>;
export declare type CommentRule = {
    value: string;
} & BaseRule<RuleKind.Comment>;
declare type FontFaceRule = {
    declarations: StyleDeclaration[];
    raws: BasicRaws;
} & BaseRule<RuleKind.FontFace>;
declare type CharsetRule = {
    value: string;
    raws: BasicRaws;
} & BaseRule<RuleKind.Charset>;
declare type BaseInclude = {
    mixinName: IncludeReference;
    range: StringRange;
    declarations: StyleDeclaration[];
    rules: StyleRule[];
    raws: BasicRaws;
};
declare type IncludeRule = BaseInclude & BaseRule<RuleKind.Include>;
export declare type MixinRule = {
    name: MixinName;
    raws: BasicRaws;
    declarations: StyleDeclaration[];
    range: StringRange;
    rules: StyleRule[];
} & BaseRule<RuleKind.Mixin>;
export declare type MixinName = {
    id: string;
    value: string;
    range: StringRange;
};
export declare type ExportRule = {
    rules: Rule[];
    range: StringRange;
    raws: BasicRaws;
} & BaseRule<RuleKind.Export>;
export declare type ConditionRule = MediaRule;
export declare type ChildRule = any;
export declare type Rule = StyleRule | ConditionRule | MixinRule | ExportRule | CharsetRule | CommentRule | MediaRule | FontFaceRule | IncludeRule | KeyframesRule | KeyframeRule;
export declare type StyleExpression = Rule | Include | MixinName | IncludePart | IncludeReference | StyleDeclaration | Selector;
export declare const getSheetClassNames: (sheet: Sheet, allClassNames?: string[]) => string[];
export declare const getRuleClassNames: (rule: Rule, allClassNames?: string[]) => string[];
export declare const traverseSheet: (sheet: Sheet, each: (rule: StyleExpression) => void) => boolean;
export declare const isRule: (expression: StyleExpression) => expression is Rule;
export declare const isStyleDeclaration: (expression: Expression) => expression is StyleDeclaration;
export declare const isMaybeStyleSheet: (expression: any) => expression is Sheet;
export declare const isStyleObject: (expression: any) => expression is StyleExpression;
export declare const isStyleSelector: (expression: any) => expression is Selector;
export declare const isSelector: (expression: any) => expression is Selector;
export declare const isIncludePart: (expression: Expression) => expression is IncludePart;
export declare const traverseStyleExpression: (rule: StyleExpression, each: (rule: StyleExpression) => void | boolean) => boolean;
export declare const getSelectorClassNames: (selector: Selector, allClassNames?: string[]) => string[];
export {};
